# Управление программным обеспечением

## Распространение ПО

Для GNU/Linux и прочих UNIX-подобных ОС программное обеспечение распространяется
в *пакетах*. Пакет является архивом, в котором содержится как программное
обеспечение, так и его описание, в которое входит имя программы, её версия,
список зависимостей и прочие сведения.

В этом архиве программное обеспечение может содержаться как в виде исходных
текстов, так и в предварительно скомпилированном виде. Существует много разных
форматов пакетов, которые предназначены для Debian, Red Hat, Arch, Slackware и
прочих. Для одних дистрибутивов пакет можно собрать буквально "на коленке", а
для некоторых процедура сборки пакета достаточно объёмна и муторна. На данный
момент у нас есть два наиболее популярных и распространённых форматов пакетов:
`deb` для Debian-based систем и `rpm` для Red Hat-based.

Для удобного и, что самое главное, централизованного получения программного
обеспечения, пакеты распространяются в репозиториях. У каждого крупного
дистрибутива GNU/Linux существуют свои репозитории, в которых содержатся пакеты
только для конкретной системы. Говоря простыми словами, репозиторий - это
сервер, на котором расположены какие-либо файлы, готовые для скачивания.

## Управление пакетами

Вообще, под термином "программное обеспечение" на протяжении всего руководства
подразумеваются не только какие-либо программы, которые пользователь может
запускать и использовать в своих целях, но и библиотеки, скрипты,
конфигурационные файлы и прочее. Кроме того, в один пакет очень часто
объединяются несколько программ, а также библиотек и конфигов. Например, это
хорошо заметно в пакетах `coreutils`, `util-linux` и прочих.

При сборке пакета из исходного кода в систему будет установлено как сам***о***
программное обеспечение, так и, в случае наличия, заголовочные файлы и прочие
данные, необходимые для разработчиков. Но, как правило, в известных и
распространённых дистрибутивах вроде Debian, Fedora и прочих файлы,
предназначенные для разработчиков, отделены от основного пакета. В итоге, к
примеру, в репозиториях содержатся пакеты `pkg1` и `pkg1-devel`, второй из
которых содержит эти файлы (название этого пакета может от дистрибутива к
дистрибутиву GNU/Linux изменяться). Но в Calmira GNU/Linux-libre (как и,
наверно, в других source-based дистрибутивах) такого разделения нет, и при
установке пакета `pkg1` устанавливаются как основные файлы, так и файлы,
предназначенные для разработчиков. Такое разделение в своём дистрибутиве я не
сделал по следующим причинам:

1. Calmira GNU/Linux-libre - это source-based дистрибутив, в нём всё ПО
   собирается из исходного кода. При сборке практически любого ПО из исходного
   кода в систему установятся заголовочные файлы и прочие инструменты для
   разработчиков. Разделять их друг от друга в большинстве случаев сложно и
   муторно, а в некоторых случаях и невозможно из-за особенностей пакета. Кроме
   того, файлы, которые отделяют сборщики пакетов для основных бинарных
   дистрибутивов, нужны для сборки других пакетов. В итоге рождается путаница:
   пакет `pkg1` зависит от пакета `pkg2`, и `pkg1` даже установлен, но `pkg2`
   отказывается собираться, так как не находит нужных для сборки файлов из
   пакета `pkg1`. А эти файлы "добрый сборщик" вынес из `pkg1` в пакет
   `pkg1-devel`. В итоге мы получаем лишнюю головную боль как для сборщиков, так
   и для пользователей. И если пользователям бинарных дистрибутивов вроде
   Debian, Fedora и прочих на это наплевать, то мне, как пользователю
   собственного source-based дистрибутива Calmira GNU/Linux-libre, не очень.
2. В том случае, когда разделение пакета на обычную версию и версию для
   разработчиков возможно, это может осложнить дальнейшее обновление как этого
   пакета, так и некоторых других, которые используют первый в качестве
   зависимости. Это не очень хороший и безопасный для ОС подход.
3. Ну и наконец, разделение - это очень неэффективный подход. Тратится в два
   раза больше на поиск пакетов, предоставляющих файлы для разработчиков, а
   также на создание двух версий одного и того же порта. Кроме того, возникает
   вопрос: а как разделять пакет? Как сделать так, чтобы ненужные файлы не
   устанавливались? Очень многие сборочные инструкции не поддерживают опции,
   отключающей возможность установки "лишних" файлов. А что тогда делать? -
   После установки пакета удалять все "ненужные" файлы, а во второй версии
   пакета для разработчиков эти файлы устанавливать? Конечно, будь бы я
   мейнтейнером для какого-то бинарного пакета, я бы вручную делал всё это. Но я
   мейнтейнер *системы портов* source-based дистрибутива, где всё это
   неэффективно, нелогично, сложно и муторно.

### Удовлетворение зависимостей

Как при использовании пакетных менеджеров (и прочих средств для автоматизации
управления ПО), так и при ручной сборке ПО из исходного кода, приходится
удовлетворять зависимости. Это делается (в первом случае) самим пакетным
менеджером (либо человеком и пакетным менеджером, где человек получает пакеты с
зависимостями, а ПМ устанавливает всё это), либо человеком.

У пакетов существует несколько типов зависимостей:

- Необходимые;
- Рекомендуемые;
- Опциональные;
- Конфликтующие - данный тип пакетов-"зависимостей" создаёт помехи в работе
  искомого пакета. Например, заменяет некоторые его файлы своими.

Зависимости устанавливаются перед искомым пакетом, особенно это правило
действует при сборке ПО из исходного кода: без наличия нужной зависимости в
системе пакет либо не будет собран (сборка завершится ошибкой либо на этапе
конфигурирования, либо на этапе компиляции), либо будет собран некорректно.
Однако, ошибки сборки будут проявляться тогда, когда в системе отсутствует
необходимая зависимость. Рекомендуемые и опциональные лишь добавляют какой-либо
новый функционал или что-то вроде того, поэтому пользователь может и не собирать
их. Но в любом случае - как и необходимые зависимости, опциональные и
рекомендуемые должны быть собраны перед исходным пакетом.

В случае конфликтующих друг с другом пакетов всё примерно также. Только вместо
установки эти пакеты должны быть удалены перед сборкой и установкой исходного
пакета (если такие конфликтующие пакеты присутствуют в системе). Либо, в случае
необходимости присутствия конфликтующих пакетов, пользователь может отказаться
от установки исходного пакета.

## Утилиты для управления пакетами

### Пакетные менеджеры

Для управления пакетами используются специальные утилиты (называемые пакетными
менеджерами), в задачи которых входит установка пакетов, просмотр о них
информации и их удаление. По своим типам пакетные менеджеры я разделяю на две
большие группы:

1. **Низкоуровневые** - управляют только локальными пакетами, не знают про
   репозитории и прочие вещи, где удалённо находятся пакеты. Некоторые не умеют
   обрабатывать зависимости, либо имеют опцию для отключения функции обработки.
   Как правило, выступают в качестве бекенда для следующей группы ПМ. Наиболее
   известными НПМ являются `dpkg` и `rpm`.
2. **Высокоуровневые** - более продвинутое ПО, в большинстве случаев
   использующих в качестве бекенда низкоуровневые ПМ (например, `apt` и
   `apt-get` используют `dpkg`, а `dnf` и `zypper` - `rpm`[^1], но случаются и
   "смешения": `apt-get` из дистрибутива Alt GNU/Linux использует `rpm`). Более
   простые и дружелюбные к пользователю. Как правило, принцип работы простейшего
   высокоуровневого ПМ следующий:
    1. Пользователь указывает ПМ, что требуется делать. Например, установить
       пакет `pkg1`. ПМ просматривает информацию об этом пакете; в частности,
       проверяет, установлен ли пакет в систему, а также получает список его
       зависимостей.
    2. ПМ проходится по списку зависимостей и тоже самое действие из пункта 2.1
       делает и с этими пакетами.
    3. В итоге ПМ строит т.н. "дерево зависимостей", в котором в нужном порядке
       перечислены все пакеты, включая их зависимости, которые будут
       установлены.
    4. ПМ последовательно скачивает нужные пакеты из репозиториев в кеш.
    5. Распаковывает скачанные пакеты и приступает к их установке.
    6. После чего заносит в базу данных информацию об установленных пакетах.
    7. Работа ПМ завершается.

### Система портов

Кроме пакетных менеджеров есть и система портов, которая была в дистрибутивах
семейства BSD, а сейчас "перекочевала" и в некоторые дистрибутивы GNU/Linux.
Например, в Gentoo есть система Portage, управляемая `emerge`, а в Calmira
GNU/Linux есть система портов под управлением менеджера `cport`.

Система портов представлена системой директорий, в которых содержатся файлы со
сборочными инструкциями и информацией о пакете. Например, в BSD системах и
дистрибутиве Calmira GNU/Linux-libre система портов расположена в директории
`/usr/ports`.

От системы к системе строение системы портов изменяется. В системах семейства
BSD это просто набор Makefile, каких-то доп. патчей и прочих подобных файлов.
Уже в GNU/Linux, в Gentoo, это набор утилит на Python и BASH. Но мы рассмотрим
самый близкий нам пример - Calmira GNU/Linux-libre. В Calmira тоже набор
скриптов, написанных на Python и BASH, но строение несколько отличается.

Система портов в Calmira - это всё та же система директорий с некоторыми
файлами. Всё это расположено в `/usr/ports`. Поддиректории там являются
категориями ПО. В этих поддиректориях содержатся ещё одни каталоги, являющиеся
либо портами, в которых содержатся нужные файлы, либо подкатегорями ПО.

В каждой категории или подкатегории содержится файл `description` с описанием
категории/подкатегории. В том случае, если в директории расположен порт, то
список файлов будет следующим:

- `install` - BASH скрипт с инструкциями по сборке;
- `files.list` - список файлов, которые устанавливает порт в систему;
- `port.toml` - файл формата TOML, содержащий информацию о пакете и о порте.

Три указанных файла являются обязательными. Кроме них могут находиться
дополнительные:

- `port-configuration.sh` - всевозможные параметры сборки, которые удобно
  редактировать простому пользователю;
- `files/` - директория с дополнительными файлами, такими как патчами.

[^1]: не путать с одноимённым форматом пакетов!
